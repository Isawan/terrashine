use std::hash::{DefaultHasher, Hash, Hasher};
use std::{fs, io, path::Path, process::Command};

/// Copy files from source to destination recursively.
pub fn copy_recursively(source: impl AsRef<Path>, destination: impl AsRef<Path>) -> io::Result<()> {
    fs::create_dir_all(&destination)?;
    for entry in fs::read_dir(source)? {
        let entry = entry?;
        let filetype = entry.file_type()?;
        if filetype.is_dir() {
            copy_recursively(entry.path(), destination.as_ref().join(entry.file_name()))?;
        } else {
            fs::copy(entry.path(), destination.as_ref().join(entry.file_name()))?;
        }
    }
    Ok(())
}

pub fn generate_tailwind() -> io::Result<(String, String)> {
    // Check if tailwindcss is available
    let tailwind_test = Command::new("tailwindcss").arg("--help").output();
    
    match tailwind_test {
        Ok(output) => {
            let version_info = String::from_utf8_lossy(&output.stdout);
            println!("cargo:warning=Found tailwindcss: {}", version_info.lines().next().unwrap_or("unknown"));
        }
        Err(_) => {
            println!("cargo:warning=tailwindcss not found. Using pre-compiled CSS file.");
            println!("cargo:warning=For UI development, install with: npm install -g @tailwindcss/cli@^4.0");
            
            // Use existing CSS when tailwindcss is not available
            let static_css = "resources/ui/static/tailwind.css";
            if Path::new(static_css).exists() {
                return Ok(("tailwind.css".to_string(), static_css.to_string()));
            }
        }
    }
    
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let css_path = format!("{}/tailwind.css", &out_dir);
    
    // Try to run tailwindcss
    let output = Command::new("tailwindcss")
        .args([
            "--input",
            "style.css",
            "--output",
            &css_path,
            "--minify",
            "--cwd=resources/ui",
        ])
        .output()?;

    if !output.status.success() {
        eprintln!(
            "Tailwind CSS generation failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
        
        // Fallback to pre-compiled CSS if generation fails
        println!("cargo:warning=Falling back to pre-compiled CSS due to generation error");
        let static_css = "resources/ui/static/tailwind.css";
        if Path::new(static_css).exists() {
            return Ok(("tailwind.css".to_string(), static_css.to_string()));
        }
        
        return Err(io::Error::new(
            io::ErrorKind::Other,
            "Tailwind CSS generation failed",
        ));
    }

    // Copy the generated CSS to the static folder so it gets embedded
    let static_css_path = "resources/ui/static/tailwind.css";
    fs::copy(&css_path, &static_css_path)?;
    println!("cargo:warning=Generated CSS copied to {}", static_css_path);

    // Save the generated CSS file with hash (for future cache-busting implementation)
    let mut hasher = DefaultHasher::new();
    fs::read_to_string(&css_path)?.hash(&mut hasher);
    let hash = hasher.finish();
    let filename = format!("tailwind-{}.css", hash);

    let ui_dir = format!("{}/ui", &out_dir);
    fs::create_dir_all(&ui_dir)?;

    // let rustc know about the generated file as an environment variable
    Ok((filename, css_path))
}

// generated by `sqlx migrate build-script`
fn main() {
    // trigger recompilation when a new migration is added
    println!("cargo:rerun-if-changed=migrations");
    println!("cargo:rerun-if-changed=resources/ui");

    // let rustc know about the generated file as an environment variable
    let (filename, css_path) = generate_tailwind().expect("Error generating Tailwind CSS");
    println!("cargo:rustc-env=TAILWIND_CSS_NAME={}", filename);
    println!("cargo:rustc-env=TAILWIND_CSS_PATH={}", css_path);
}
