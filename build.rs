use std::{fs, io, path::Path, process::Command};

/// Copy files from source to destination recursively.
pub fn copy_recursively(source: impl AsRef<Path>, destination: impl AsRef<Path>) -> io::Result<()> {
    fs::create_dir_all(&destination)?;
    for entry in fs::read_dir(source)? {
        let entry = entry?;
        let filetype = entry.file_type()?;
        if filetype.is_dir() {
            copy_recursively(entry.path(), destination.as_ref().join(entry.file_name()))?;
        } else {
            fs::copy(entry.path(), destination.as_ref().join(entry.file_name()))?;
        }
    }
    Ok(())
}

pub fn generate_tailwind() -> io::Result<(String, String)> {
    const REQUIRED_TAILWIND_VERSION: &str = "v4.";  // Major version
    
    // Check if tailwindcss is available and get version
    let tailwind_check = Command::new("tailwindcss")
        .arg("--help")
        .output();

    match tailwind_check {
        Ok(output) if output.status.success() => {
            let output_str = String::from_utf8_lossy(&output.stdout);
            // Extract version from first line of help output (e.g., "â‰ˆ tailwindcss v4.1.11")
            let version = output_str.lines().next().unwrap_or("").trim().to_string();
            println!("cargo:warning=Found tailwindcss: {}", version);
            
            // Check if it's v4.x
            if !version.contains(REQUIRED_TAILWIND_VERSION) {
                println!("cargo:warning=WARNING: Expected Tailwind CSS v4.x, found {}. CSS generation may fail.", version);
                println!("cargo:warning=Install with: npm install -g @tailwindcss/cli@^4.0");
            }
            
            // For now, use existing CSS due to v4 CLI compatibility issues
            println!("cargo:warning=Using pre-compiled CSS file for now");
            return Ok(("tailwind.css".to_string(), "resources/ui/static/tailwind.css".to_string()));
        }
        _ => {
            println!("cargo:warning=tailwindcss not found. Using pre-compiled CSS file.");
            println!("cargo:warning=For UI development, install with: npm install -g @tailwindcss/cli@^4.0");
            // If tailwindcss is not available, use the existing CSS file
            return Ok(("tailwind.css".to_string(), "resources/ui/static/tailwind.css".to_string()));
        }
    }

    let out_dir = std::env::var("OUT_DIR").unwrap();
    let temp_css_path = format!("{}/tailwind_temp.css", &out_dir);
    
    // Generate CSS to temp location
    let output = Command::new("tailwindcss")
        .args([
            "--input",
            "style.css",
            "--output",
            &temp_css_path,
            "--minify",
            "--cwd=resources/ui",
        ])
        .output()?;

    if !output.status.success() {
        eprintln!(
            "Tailwind CSS generation failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
        return Err(io::Error::new(
            io::ErrorKind::Other,
            "Tailwind CSS generation failed",
        ));
    }

    // Copy the generated CSS to the static folder so it gets embedded
    let static_css_path = "resources/ui/static/tailwind.css";
    fs::copy(&temp_css_path, &static_css_path)?;
    
    println!("cargo:warning=Generated CSS copied to {}", static_css_path);

    // For now, return a fixed filename since templates use /ui/static/tailwind.css
    Ok(("tailwind.css".to_string(), static_css_path.to_string()))
}

// generated by `sqlx migrate build-script`
fn main() {
    // trigger recompilation when a new migration is added
    println!("cargo:rerun-if-changed=migrations");
    println!("cargo:rerun-if-changed=resources/ui");

    // let rustc know about the generated file as an environment variable
    let (filename, css_path) = generate_tailwind().expect("Error generating Tailwind CSS");
    println!("cargo:rustc-env=TAILWIND_CSS_NAME={}", filename);
    println!("cargo:rustc-env=TAILWIND_CSS_PATH={}", css_path);
}
